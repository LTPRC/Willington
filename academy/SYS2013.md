# SYS201 - Computer Networks - TCP协议

返回[Bulletin](./bulletin.md)

返回[SYS301 - Distributed Systems](./SYS301.md)

[TOC]

## TCP协议<img src="./icons/kaikeba.gif" /><img src="./icons/mashibing.gif" />

Transmission Control Protocol (TCP)是一个可以提供可靠的、支持全双工、连接导向的协议，因此传输数据必须先建立**连接**。

### 连接

连接，又称会话(session)，是虚拟、抽象的概念，能确保两个通信的程序彼此在线，加快响应请求速度，但是消耗更多资源。

### 单工 半双工 双工<img src="./icons/gupao.gif" /><img src="./icons/mashibing.gif" />

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201023.png" />

### 主要特点

- TCP 能够确保连接的建立和数据包的发送。

- TCP 支持错误重传机制。

- TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送。

- TCP 能够提供错误校验和，甄别有害的数据包。

### 三次握手<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" /><img src="./icons/mashibing.gif" /><img src="./icons/bytedance.gif" /><img src="./icons/bbbbzxlb.gif" /><img src="./icons/baidu.gif" />

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201024.png" />

#### 第一次握手

(SYN=1, seq=x)

客户端–发送带有SYN标志(*Synchronize Sequence Numbers*)的数据包–一次握手–服务端

发送完毕后，客户端进入SYN_SENT状态。

Client什么都不能确认；

Server确认了对方发送正常。

##### 第一次握手重传

正常情况下，服务器会在几毫秒内返回 SYN+ACK, 但如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，重发的次数由 tcp_syn_retries 参数控制，默认是 5 次。

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手。所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201024.png" />

#### 第二次握手

(SYN=1, ACK=1, seq=y, ACKnum=x+1)

服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端

发送完毕后，服务器端进入SYN_RCVD状态。

Client确认了：自己发送、接收正常，对方发送、接收正常；

Server确认了：自己接收正常，对方发送正常。

##### 第二次握手为什么要传回SYN？

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

##### 第二次握手为什么要传了SYN还要传ACK？

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证，目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

##### 第二次握手重传

如果服务器没有收到ACK, 就会重发SYN+ACK报文同时一直处于SYN_RCV状态。当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数，反之则可以调小重发次数。

修改重发次数的方法是调整tcp_synack_retries参数。tcp_synack_retries的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、16 秒，最后一次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。

##### 为什么前两次握手不可以携带数据？

根据TCP协议的RFC793文档，带有SYN标志的过程包是不可以携带数据的，也就是说三次握手的前两次是不可以携带数据的（逻辑上看，连接还没建立，携带数据好像也有点说不过去）。

##### 半连接队列

TCP第二次握手后，服务端Linux内核就会建立一个“半连接队列”来维护未完成的握手信息。当半连接队列溢出后，服务端就无法再建立新的连接。

SYN攻击，攻击的是就是这个半连接队列。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201026.png" />

###### 查看失败

我们可以通过该netstat –s | grep "SYNs to LISTEN"命令查看由于SYN半连接队列已满引发的TCP连接失败次数。隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象。

###### 长度

要想增大半连接队列，不能只单纯增大tcp_max_syn_backlog的值，还需一同增大somaxconn和backlog, 也就是增大accept队列。

- somaxconn是Linux内核的参数，默认值是128，可以通过net.core.somaxconn来设置其值。

- backlog是listen(int sockfd, int backlog) 函数中的backlog大小。Tomcat, Nginx, Apache这些常见的Web服务的backlog默认值都是 511。

###### syncookies

开启syncookies功能就可以在不使用SYN半连接队列的情况下成功建立连接，工作原理是：服务器根据当前状态计算出一个值，放在己方发出的SYN+ACK报文中发出，当客户端返回ACK报文时，取出该值验证，如果合法，就认为连接建立成功。syncookies 参数主要有以下三个值：

- 0值，表示关闭该功能。

- 1值，表示仅当SYN半连接队列放不下时再启用它，设置成1即可应对SYN攻击。

- 2值，表示无条件开启功能。

#### 第三次握手

(ACK=1，ACKnum=y+1)

客户端–发送带有带有ACK标志的数据包–三次握手–服务端

发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，即可以开始数据传输。

Client确认了：自己发送、接收正常，对方发送、接收正常；

Server确认了：自己发送、接收正常，对方发送接收正常。

##### 为什么第三次握手可以携带数据？

根据TCP协议的RFC793文档，“Data or controls which were queued for transmission may be included”，也就是说标准表示，第三次握手的ACK包是可以携带数据。

##### 全连接队列

服务器收到 ACK 后连接建立成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列（accept队列），等待进程调用accept函数时把连接取出来。

如果进程不能及时地调用就会造成全连接队列溢出，最终导致建立好的TCP连接被丢弃。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201027.png" />

###### 查看失败

我们可以使用netstat –s | grep overflowed命令来查看全连接队列溢出导致丢失的TCP连接个数。如果持续不断地有连接因为accept队列溢出被丢弃，就应该调大backlog以及somaxconn参数。

###### 长度

accept队列的长度取决于min(somaxconn, backlog)。

可以通过ss -ltn命令查看：

- Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端accept()的TCP连接。

- Send-Q：全连接队列最大长度。

###### RST复位

丢弃连接只是Linux的默认行为，我们还可以选择向客户端发送RST复位报文告诉客户端连接已经建立失败。tcp_abort_on_overflow参数共有两个值：

- 0
  - 如果全连接队列满了，那么server扔掉client发过来的ack.
  - 通常情况下应当设置为0，更有利于应对突发流量。

- 1
  - 如果全连接队列满了，server发送一个RST包给client, 表示废掉这个握手过程和这个连接。
  - 打开这一功能需要将tcp_abort_on_overflow参数设置为1，全连接队列溢出会有很多connection reset by peer错误出现的现象。

#### 如何绕过三次握手？<img src="./icons/paypal.gif" />

三次握手建立连接造成的后果就是，HTTP 请求必须在一个 RTT（从客户端到服务器一个往返的时间）后才能发送。在 Linux 3.7 内核版本之后，提供了 **TCP Fast Open** 功能，这个功能可以减少 TCP 连接建立的时延。

在 Linux 系统中，可以通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能：

| tcp_fastopn的值 | 意义                                                |
| --------------- | --------------------------------------------------- |
| 0               | 关闭                                                |
| 1               | 作为客户端使用 Fast Open 功能                       |
| 2               | 作为服务端使用 Fast Open 功能                       |
| 3               | 无论作为客户端还是服务器，都可以使用 Fast Open 功能 |

TCP Fast Open 功能需要客户端和服务端同时支持，才有效果。

##### 首次建立连接

- 客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；

- 支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；

- 客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。

所以第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/SYS201028.png" />

##### 再次建立连接

- 客户端发送 SYN 报文，该报文包含「数据」（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 Cookie；

- 支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：
  - 如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；
  - 如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；

- 如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，这就减少了握手带来的 1 个 RTT 的时间消耗；

- 客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；

- 此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。

之后发起 HTTP GET 请求的时候，可以绕过三次握手，这就减少了握手带来的 1 个 RTT 的时间消耗。

#### 三次握手的优化

##### 客户端的优化

- 当客户端发起 SYN 包时，可以通过 **tcp_syn_retries** 控制其重传的次数。

##### 服务端的优化

- 当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 **tcp_max_syn_backlog** **somaxconn** **backlog** 参数来调整 SYN 半连接队列的大小。
- 服务端回复 SYN+ACK 的重传次数由 **tcp_synack_retries** 参数控制。如果遭受 SYN 攻击，应把 tcp_syncookies 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。
- 服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。
- 可以通过 ss -lnt 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 **tcp_abort_on_overflow** 设置为 1 ，表示用 RST 通知客户端连接建立失败。
- 如果 accpet 队列溢出严重，可以通过 listen 函数的 **backlog** **somaxconn** 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)

##### 绕过三次握手

TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 **tcp_fastopen** 开启该功能，同时必须保证服务端和客户端同时支持。

