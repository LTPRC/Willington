# CSE311 - Multi-thread Programming - CAS

返回[Bulletin](./bulletin.md)

返回[CSE311 - Multi-thread Programming](./CSE311.md)

[TOC]

## 线程安全<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" />

线程安全是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。即在多线程场景下，不发生有序性、原子性以及可见性问题。

Java中主要通过加锁来实现线程安全。

### Unsafe VS Varhandle<img src="./icons/mashibing.gif" />

C/C++类Unsafe通过将一个值0和1之间来回切换的变量作为标识，从而进行CAS操作。但它不符合Java标准，不推荐开发者使用，所以在JDK 9之后，官方推荐Varhandle代替Unsafe的大部分功能。Varhandle更加安全、性能更好。

### 公平锁<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" /><img src="./icons/bytedance.gif" />

公平锁是一种思想，指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。

公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在wait，如果有，自己要挂起、加到队列后面，然后唤醒队列最前面的线程。

<img src=".\images\CSE311021.png" />

### 非公平锁<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" /><img src="./icons/bytedance.gif" />

非公平锁是一种思想，JVM按就近原则分配锁。

非公平锁后来的线程有一定几率逃离被挂起的开销，减少了一次挂起和唤醒。线程切换的开销其实就是非公平锁效率高于公平锁的原因。

除非程序有特殊需要，否则最常用非公平锁的分配机制。

<img src=".\images\CSE311022.png" />

### 自旋锁<img src="./icons/alibaba.gif" /><img src="./icons/ausa.gif" /><img src="./icons/qinlin.gif" /><img src="./icons/bytedance.gif" /><img src="./icons/mashibing.gif" />

Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）因为经常配合循环操作，直到完成为止，所以泛指一类操作。CAS并不是一种实际的锁，它仅仅是实现乐观锁的一种思想，java中的乐观锁基本都是通过CAS操作实现的。

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋，默认限定次数是10），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。

自旋锁是非公平锁，并不能保证线程获取锁的顺序。

自旋锁在JDK1.4就已引入，默认关闭，在JDK6中改为默认开启。

#### CAS算法<img src="./icons/meituan.gif" /><img src="./icons/xiaohui.gif" /><img src="./icons/bbbbzxlb.gif" />

CAS算法有三个操作数：内存位置V、旧的预期值A和新值B。

当且仅当V符合预期值A时，CAS用新值B原子地更新V的值，否则不要更改该位置，只告诉这个位置现在的值即可。

整个比较并交换的操作是由硬件直接支持的原子操作。

#### 优点<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" /><img src="./icons/xiaohui.gif" /><img src="./icons/baidu.gif" /><img src="./icons/mashibing.gif" /><img src="./icons/meituan.gif" />

自旋锁尽可能的减少线程的阻塞，这对于锁的**竞争不激烈**，且**占用锁时间非常短**的代码块来说，会有大幅度的性能提升。因为此时自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗。

#### 缺点<img src="./icons/alibaba.gif" /><img src="./icons/paypal.gif" /><img src="./icons/xiaohui.gif" /><img src="./icons/baidu.gif" /><img src="./icons/mashibing.gif" /><img src="./icons/meituan.gif" />

##### CPU开销较大

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

而重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源。所以在特殊情况下重量级锁要比自旋锁性能更高。

##### 不能保证代码块的原子性

CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

##### ABA问题

自旋锁存在"ABA"问题，假若一个变量初次读取是A，在compare阶段依然是A，但其实可能在此过程中，它先被改为B，再被改回A，而CAS是无法意识到这个问题的。CAS只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的ABA漏洞。

*例如：存款余额初始为100，发起原子操作将存款从100扣到50，由于网络阻塞再发起一次同一个操作。正常情况下只有一个操作生效，然而如果此时有另一个操作将存款从50补充到100，就有可能导致两个扣款操作都被执行。*

这个问题的解决方案可以使用版本号标识，每操作一次version 加 1。在 java 5 中，已经提供了 AtomicStampedReference 来解决问题。

基础类型简单值不需要版本号。

#### 自适应自旋<img src="./icons/alibaba.gif" />

JDK1.6引入了适应性自旋锁，意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间、以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

如果在同一个锁上，自旋刚刚成功获得过锁且持有锁的线程正在运行，虚拟机会认为这次自旋也很可能成功，进而允许自旋持续更久。

如果自旋很少成功，以后获取锁时将可能直接省略掉自旋，避免浪费处理器资源。

有了自适应自旋，随着程序运行时间的增长，虚拟机对程序锁的状况预测就会越来越精准。

### 乐观锁<img src="./icons/netease.gif" /><img src="./icons/paypal.gif" /><img src="./icons/kingdee.gif" /><img src="./icons/bytedance.gif" /><img src="./icons/baidu.gif" /><img src="./icons/alibaba.gif" />

乐观锁（Optimistic Lock）是一种乐观思想，假定当前环境是读多写少、不会发生并发冲突，所以每次去拿数据的时候都认为别人不会修改，不会上锁。

在提交更新的时候，乐观锁会通过以下方法判断在此期间别人有没有去更新这个数据：用户在写之前先读出当前版本号，然后乐观锁进行加锁操作，等到用户提交时，比较当前版本号和用户读到的版本号。如果版本号一样则更新（更新期间加锁保证原子性），否则重复上述“读-比较-写”的操作。

乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

#### 实现

Java中的乐观锁基本都是通过CAS操作比较并替换实现的，比较当前值（主内存中的值）与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。一般使用数据版本（Version）或者时间戳（timestamp）记录机制。

## 并发包JUC<img src="./icons/netease.gif" /><img src="./icons/paypal.gif" /><img src="./icons/bytedance.gif" /><img src="./icons/baidu.gif" /><img src="./icons/meituan.gif" />

java.util.concurrent包（简称JUC包）中，提供了大量的同步与并发的工具类，是多线程编程的“利器”。

### locks

包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能。

#### Lock接口

Lock接口是使用户能够以非块结构来实现互斥同步，摆脱了语言特性束缚。Lock在类库层面实现同步，并未用到 synchronized，而是利用了volatile的可见性。

#### Condition接口<img src="./icons/alibaba.gif" /><img src="./icons/baidu.gif" /><img src="./icons/citic.gif" /><img src="./icons/meituan.gif" />

Condition依赖于Lock接口，是在java 1.5中出现的。

生成一个Condition的基本代码：

```java
lock.newCondition();
```

##### await()/signal()/signalAll()

Condition类的await()/signal()/signalAll()用来替代传统的Object的wait()/notify()实现线程间的协作，更加安全和高效。必须在lock保护之内（lock.lock()和lock.unlock之间）才可以调用。

- Conditon中的await()对应Object的wait()；
- Condition中的signal()对应Object的notify()；
- Condition中的signalAll()对应Object的notifyAll()。

```java
public class AwaitSignalExample {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```
before
after
```

### ReentrantLock<img src="./icons/netease.gif" /><img src="./icons/alibaba.gif" /><img src="./icons/baidu.gif" /><img src="./icons/meituan.gif" />

ReentrantLock是Lock接口的最常见的实现。

```java
public class LockExample {
    private Lock lock = new ReentrantLock();
    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> lockExample.func());
    executorService.execute(() -> lockExample.func());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

#### 特有功能

**可重入**

<u>非公平锁的实现</u>

非公平所通过nonfairTryAcquire方法获取锁，成功获取锁的线程再次获取锁将增加同步状态值，释放同步状态时将减少同步状态值。该方法将同步状态是否为0作为最终释放条件，释放时将占有线程设置为null并返回true. 如果锁被获取了n次，那么前n-1次tryRelease方法必须都返回false, 只有同步状态完全释放才能返回true.

<u>公平锁的实现</u>

公平锁使用tryAcquire方法，该方法与nonfairTryAcquire的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回true表示有线程比当前线程更早请求锁，因此需要等待前驱线程获取并释放锁后才能获取锁。

**等待可中断**

持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。

**公平锁**

ReentrantLock在默认情况下是非公平的，在锁被释放时，任何线程都有机会获得锁。一旦使用了公平锁，多个线程在等待同一个锁时必须按照申请锁的顺序来依次获得锁，性能会急剧下降，影响吞吐量。

可以通过构造方法指定公平锁，fair的取值代表了这个锁是公平锁还是非公平锁。无参数或false代表非公平锁，true代表公平锁。

```java
    /**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
```

**锁绑定多个条件**

synchronized中锁对象的wait跟notify可以实现一个隐含条件，如果要和多个条件关联就不得不额外添加锁，而ReentrantLock可以多次调用newCondition创建多个条件。

#### AQS<img src="./icons/baidu.gif" /><img src="./icons/paypal.gif" /><img src="./icons/mashibing.gif" /><img src="./icons/alibaba.gif" />

java.util.concurrent大大提高了并发性能，AQS被认为是J.U.C的核心。

java.util.concurrent.locks包提供了AQS队列同步器（AbstractQueuedSynchronizer），是用来构建锁或其他同步组件的基础框架，是除了java自带的synchronized关键字之外的锁机制。

AQS是自旋锁，在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功。

- 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态；
- 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。AQS的这个机制是用CLH队列锁实现的，将暂时获取不到锁的线程加入到队列中。

#### CLH锁<img src="./icons/ithk01.gif" />

CLH锁(Craig, Landin, and Hagersten三个人的名字)，它是基于链表实现的自旋锁，它不断的轮询前驱的状态，如果前驱释放锁，它就结束自旋转。CLH锁是公平锁，FIFO.

<img src=".\images\CSE311015.png" />

CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。

##### 实现

AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

线程持有自己的node变量，node中有一个locked属性，true代表需要锁，false代表不需要锁。

线程持有前驱的node引用，轮询前驱node的locked属性，true的时候自旋，false的时候代表前驱释放了锁，结束自旋。

```java
private transient volatile Node head;
private transient volatile Node tail;
```

head节点是一个哨兵节点，不存放实际的“线程”节点（使用Node的无参构造函数）。

tail指向链表的最后一个节点，当新增节点时，将新节点作为当前tail的下一个节点，通过CAS设置成功后,将新节点设为新的tail节点即可。

| 步骤                                                         | 图示                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 初始化的时候tail指向一个类似head的节点，此时node的locked属性为false，preNode为空。 | <img src=".\images\CSE311016.png" /> |
| 当线程A进来的时候，线程A持有的node节点，node的locked属性为true，preNode指向之前的head节点。 | <img src=".\images\CSE311017.png" /> |
| 当线程B进来的时候，线程B持有的node节点，node的locked属性为true，preNode指向线程A的node节点，线程B的node节点locked属性为true，线程A轮询线程B的node节点的locked状态，为true自旋。 | <img src=".\images\CSE311018.png" /> |
| 线程A执行完后释放锁（修改locked属性为false），线程B轮询到线程A的node节点locked属性为false，结束自旋。 | <img src=".\images\CSE311019.png" /> |

##### 同步状态state

AQS还使用一个volatile int state变量作为共享资源代表同步状态。如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。

```java
private volatile int state;

//读取当前state
protected final int getState() {
    return state;
}

//直接写入，不考虑当前值
protected final void setState(int newState) {
    state = newState;
}

//保证读-写的原子性
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, update);
}
```

AQS中还定义了一些未实现的方法（抛出UnsupportedOperationException异常）：

- tryAcquire(int) 尝试获取state

- tryRelease(int) 尝试释放state

- tryAcquireShared(int) 共享的方式尝试获取

- tryReleaseShared(int) 共享的方式尝试释放

- isHeldExclusively() 判断当前是否为独占锁

这些方法是子类需要实现的，可以选择实现其中的一部分。根据实现方式的不同，可以分为两种：共享锁和独占锁。这两种锁多用于数据库中的事物操作，主要针对读和写的操作。

###### 独占锁（排它锁、互斥锁、写锁或X锁）<img src="./icons/alibaba.gif" /><img src="./icons/kingdee.gif" /><img src="./icons/bytedance.gif" />

独占锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁。获得锁的事务即能读数据又能修改数据。

获取同步状态时，调用acquire方法，维护一个同步队列，使用tryAcquire方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过addWaiter方法加入到同步队列的尾部，在队列中自旋。之后调用acquireQueued方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞，被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且自己成功获取了同步状态。

释放同步状态时，同步器调用tryRelease方法释放同步状态，然后调用unparkSuccessor方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。

可以用来实现：

- ReentrantLock

- ReentrantReadWriteLock.WriteLock

###### 共享锁（读锁或S锁）<img src="./icons/alibaba.gif" /><img src="./icons/kingdee.gif" /><img src="./icons/bytedance.gif" />

共享锁如果被一个线程占用，其他线程也可以获得同一个共享锁，但是不能获得同一个数据上的独占锁。

获取同步状态时，调用acquireShared方法，该方法调用tryAcquireShared方法尝试获取同步状态，返回值为int类型，返回值不小于0表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。

释放同步状态时，调用releaseShared方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于tryReleaseShared方法必须确保同步状态安全释放，通过循环CAS保证，因为释放同步状态的操作会同时来自多个线程。

可以用来实现：

- ReentrantReadWriteLock.ReadLock

- CountDownLatch

- CyclicBarrier

- Semaphore

##### 节点属性

```java
volatile Node prev;
volatile Node next;
volatile Thread thread;

volatile int waitStatus;
//可以被赋值为以下常量：
static final int CANCELLED = 1;
static final int SIGNAL = -1;
static final int CONDITION = -2;
static final int PROPAGATE = -3;

Node nextWaiter;
//可以被赋值为以下常量：
//共享锁
static final Node SHARED = new Node();
//独占锁
static final Node EXCLUSIVE = null;
```

##### 构造函数

```java
//不存放任何线程，用于生成哨兵节点
Node();
//用于锁
Node(Thread thread, Node mode);
//用于Condition
Node(Thread thread, int waitStatus);
```

##### 优点

空间复杂度低，如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+n)。

##### 缺点

在NUMA(Non-Uniform Memory Access)非一致存储访问的情况下，CPU分成不同模块，访问内存所需时间不相同，会导致锁性能下降。

#### MCS锁

MCS(John Mellor-Crummey和Michael Scott)锁可以解决CLH锁的缺点。MCS Spinlock是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，不是像CLH自旋锁一样轮询前驱的状态，而是由前驱主动通知，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。

<img src=".\images\CSE311020.png" />

每个线程持有一个自己的node，node有一个locked属性，true表示等待获取锁，false表示可以获取到锁，并且持有下一个node（后继者）的引用（可能存在）。

线程在轮询自己node的locked状态，true表示锁被其他线程暂用，等待获取锁，自旋。

线程释放锁的时候，修改后继者（nextNode）的locked属性，通知后继者结束自旋。

### atomic

包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础。

atomic包出现自JDK 1.5, 里面一共提供了13个类，分为4种类型：

- 原子更新基本类型

- 原子更新数组

- 原子更新引用

- 原子更新属性

这13个类都是使用C++的Unsafe类实现的包装类。

#### 原子操作<img src="./icons/meituan.gif" /><img src="./icons/bytedance.gif" /><img src="./icons/bbbbzxlb.gif" /><img src="./icons/kaikeba.gif" />

当程序更新一个变量时，如果是多线程同时更新这个变量，可能得到的结果与期望值不同。

比如：有一个变量i，A线程执行i+1,B线程也执行i+1，经过两个线程的操作后，变量i的值可能不是期望的3，而是2。这是因为，可能在A线程和B线程执行的时候拿到的i的值都是1，这就是线程不安全的更新操作。

通常可以通过atomic包或者synchronized加锁实现。

##### 原理<img src="./icons/mashibing.gif" /><img src="./icons/bytedance.gif" />

以原子操作方法getAndAddInt为例：

```java
@HotSpotIntrinsicCandidate
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
```

这段代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：

- 获取当前值。

- 当前值+1，计算出目标值。

- 进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤。

getIntVolatile方法的作用是获取变量的当前值，通过volatile保证获得的值是最新值。

unsafe.cpp中Unsafe_CompareAndSwapInt() 对以上方法进行了实现

```c++
return Atomic::cmpxchg()
```

最终的实现是汇编实现

```assembly
lock->cmpxchg
__asm__ LOCK_IF_MP
```

多个CPU操作一个变量，不想被其他CPU打断就加一个lock（锁总线），不允许其他CPU访问变量，从而不会被打断，这就是CAS的底层实现。

#### LongAdder<img src="./icons/mashibing.gif" />

JDK 1.8出现的LongAdder的效率超过加锁和原子类，是因为它的内部做了分段锁，将一个变量拆成多个变量进行存储，用空间换时间，提升了线程并发。

| 原子类                               | LongAdder                            |
| ------------------------------------ | ------------------------------------ |
| <img src=".\images\CSE311023.png" /> | <img src=".\images\CSE311024.png" /> |

```java
public class LongAdder extends Striped64 implements Serializable {
	// 对结果累加 x
	public void add(long x) {...}
	
    // 获取结果，如果当前存在并发更新，结果不准确
    // 如果没有并发更新，那么结果是准确的
	public long sum() {...}
    
    // 结果清零，同样是在非并发更新下，才能保证准确性
    public void reset() {...}
}
```

### executor

散落在java.util.concurrent包中，提供线程池相关的功能。

### collections

散落在java.util.concurrent包中，提供并发容器相关功能。

### tools

散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能。



