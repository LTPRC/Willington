# CSE301 - Java Virtual Machine - 垃圾回收

返回[Bulletin](./bulletin.md)

返回[CSE274 - Data Structure and Algorithms](./CSE274.md)

[TOC]

## 对象

### 创建过程<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/meituan.gif" /><img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/mashibing.gif" />

- new 类名
- 根据new的参数，在常量池中定位类的符号引用。
  - 如果没有定位到，说明类还没有被加载，则进行类的加载、解析和初始化
- 为对象在堆中分配内存
- 将分配的内存初始化为0值
- 调用对象的<init>方法

以以下源码为例：

```java
class T {
    int m = 8;
}
T t = new T();
```

可以使用jclasslibrary插件展示字节码。

```assembly
0 new #2 <T> ;申请一块内存存储T对象
3 dup ;复制一份上面的引用，用于下一步处理，可以先不考虑其逻辑
4 invokespecial #3 <T.<init>> ;半初始化状态，成员的值赋为默认值
7 astore_1 ;变量和新建的对象之间建立关联
8 return ;暂时忽略
```

#### invoke方法调用指令<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/mashibing.gif" />

JVM调用方法有五条指令，分别是：

| 调用指令        | 备注                                                         |
| --------------- | ------------------------------------------------------------ |
| invokestatic    | 用来调用static方法（类方法）                                 |
| invokespecial   | 用来调用需要特殊处理的实例方法，私有方法，父类方法(super.)，初始化方法。在对象的创建过程中，new之后很多都会执行<init>方法，就是依赖字节码中是否包含invokespecial指令。多数方法都是调用invokespecial. |
| invokevirtual   | 用于调用涉及到多态的方法。调用的哪个对象的方法，就把它被调用的方法压入栈中。 |
| invokeinterface | 调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适当的方法进行调用。 |
| invokedynamic   | Java 1.7加入，在执行动态语言（运行时产生class文件）时调用。  |

### 存储布局<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/meituan.gif" /><img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/paypal.gif" /><img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/sf.gif" /><img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/icons/mashibing.gif" />

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/CSE301006.png" />

使用**jol**工具查看对象的存储布局：

```java
public static void main(String[] args) {
    M m = new M();
    System.out.println(ClassLayout.parseInstance(m).toPrintable());
}
static class M {
}
```

```shell
com.github.ltprc.jvm.jol.JolTest$M object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           40 02 06 00 (01000000 00000010 00000110 00000000) (393792)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

引用变量 = 4Byte

Object对象 = 8(Markword) + 4(Classpointer) + 4(Padding) = 16Byte

```java
static class M {
    int a;
}
```

```shell
com.github.ltprc.jvm.jol.JolTest$M object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           40 02 06 00 (01000000 00000010 00000110 00000000) (393792)
     12     4    int M.a                                       0
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
```

```java
static class M {
    boolean b;
}
```

```shell
com.github.ltprc.jvm.jol.JolTest$M object internals:
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4           (object header)                           40 02 06 00 (01000000 00000010 00000110 00000000) (393792)
     12     1   boolean M.b                                       false
     13     3           (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 3 bytes external = 3 bytes total
```

Boolean类型会进行“内补齐”，从1补3位变成4.

```java
static class M {
	String s;
}
```

```shell
com.github.ltprc.jvm.jol.JolTest$M object internals:
 OFFSET  SIZE               TYPE DESCRIPTION                               VALUE
      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4                    (object header)                           40 02 06 00 (01000000 00000010 00000110 00000000) (393792)
     12     4   java.lang.String M.s                                       null
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
```

### 对象引用<img src="./icons/baidu.gif" />

#### 指针

指针是地址，在运行时可以改变所指向的地址值，可以被重新赋值，以指向另一个对象。

#### 引用

引用是别名，一旦与某个对象绑定后就不再改变，不过指向的内容可以改变。

指针和引用两者的效率理论上是一致的。

### 对象定位<img src="./icons/meituan.gif" /><img src="./icons/mashibing.gif" />

#### 句柄

引用指针 -> 实例数据指针 -> 堆-对象

引用指针 -> 类型数据指针 -> 方法区-类

##### 长处

便于GC. GC进行复制的时候，引用指针的值不需要变。

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/CSE301012.png" />

#### 直接指针

引用指针 -> 堆-对象 -> 方法区-类

##### 长处

效率高

<img src="D:/workspace-spring-tool-suite-4-4.9.0.RELEASE/Willington/academy/images/CSE301013.png" />

句柄和直接指针两者内存消耗是一样的。

### 为什么Hotspot不使用C++对象来代表Java对象？<img src="./icons/mashibing.gif" />

C++对象有个虚函数表，占空间太大，Java没有。

